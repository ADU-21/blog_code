---
title: Java系列（二）——JVM内存回收
date: 2018-02-03 23:15:15
categories: Java
tags:
- Java
---

GC（Garbage Collection 垃圾回收）使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

# 哪些内存需要回收

上文[JVM内存分配](https://www.duyidong.com/2018/01/31/jvm/)介绍了 JVM 运行时内存分配的各个部分，其中程序计数器、虚拟机栈、本地方法区都是和线程同生共死的，其内存的分配和回收都随着栈帧的进入和退出有序进行，不需要过多考虑回收问题。而 **Java 堆**和**方法区**因为其存放对象和类都是要在运行时才能确认大小，而创建的动作频繁且随机，因此这两部分区域是 GC 关注的主要区域。

# 什么时候回收

## Java 堆里的对象实例

Java 堆里存放着 JVM 中几乎所有的对象实例，判断 Stack 中哪些内存可以被回收，首先就得看哪些对象实例已经“死去”，即不可能再被使用。我们先来看两个简单的实现方式：**引用计数算法**发和**可达性分析算法**。

### 引用计数算法（Reference Counting Collector）

这是在 Python 里被使用的 GC 算法，也是 GC 早期中的早期策略，其实现就是给每一个对象添加一个应用计数器，没有一个地方引用它就加1，当应用失效时就减1，当计数器为0时则说明这个对象不再被使用。这种实现方式简单高效，却有一个比较大的问题导致主流 Java 虚拟机都没有采纳这种方式，就是它无法解决<u>循环引用</u>的问题。例子可见：[java垃圾回收之循环引用](http://blog.csdn.net/sunmenggmail/article/details/8172273)。

### 可达性分析算法（Reachability Analysis）

这种算法是真正被主流商用语言采纳的 GC 算法，其思路是通过通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链（Reference Chain），成为一个树状结构，当所有根节点（GC root）到某个对象都不可达时，则说明这个对象是不可用的。

有以下几种对象可以被作为 GC Roots:

```
- Java Stack 中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法中 Native 方法引用的对象。
```

值得注意的是，这些不可达对象并不是会立即被清理掉，而是会被进行一次标记，如果该对象覆写了 finalize() 方法且还没有被调用过，则会被放到一个叫 F-Queue 的队列中，这个 finalize 方法原本是用于手动释放非 Java 内存的，但是 JVM 并不一定会执行它；如果在 finalize 方法中对象与引用链上的任一对象发生引用，这个对象就会“起死回生”，在第二次 GC 标记 F-Queue 中对象的时候被移除回收集合。finalize 方法最多只会被执行一次，不确定性大，所以不推荐使用。

#### 关于引用

可达性分析算法中对引用的划分仅限于“引用”和“未引用”，而事实上在程序运行中还有一类“暂时没被引用”的对象，这部分对象我们希望在内存充裕的情况下保留，在内存紧张的时候再将其抛弃。因此在 JDK1.2 后，Java 将引用的概念扩充至强引用（Strong Reference）、软引用（Weak Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），分别用来描述有用（new）、有用但非必须（OOM 前回收）、非必须引用（下一次 GC 回收），以及不影响对象生命周期的引用（用于系统回收通知）。

#### 如何找到根节点

由于遍历 GC Roots 节点要求“一致性”，所以 GC 发生的时候需要暂停 Java 执行线程（Sun 称之为"Stop the world"），为了缩短 Stop the world 的时间，遍历根节点时间需要尽可能短，所以 HotSpot 使用了 OopMap 的数据结构来达到这个目的，当程序运行到安全点（Safepoint）的时候

## 方法区里的类

方法区（Method Area）对应 Java7 以前的持久代（Permanent generation），已经在 Java8中被移除，取而代之的是使用本地内存的 MetaSpace，其 GC 频率也大幅降低，只有当 MetaSpace 内存达到“MaxMetaspaceSize”值的时候才会触发一次该区域的 GC。根据 JVM 规范，满足以下三个条件的类将被定义为“可以被搜集”：

```
- 该类的所有实例都已经被回收。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
```

当然，被标记“可以回收”的类还要视 JVM 的参数（-Xnoclassgc）决定是否被回收。

# 如何回收

## 算法

在 Hotspot JVM 里，Java 堆采用分代收集（Generational Collection），在了解分代收集之前先来看几种简单的算法：

- **标记-清除算法（Mark-Sweep）**：分为“标记”和“清除”两个阶段，将需要清除的内存标记后随即清除，因为绝大部分的对象都只存在很短的时间就需要被收回，这种算法显得很低效；而且会产生大量不连续的存储空间。
- **复制算法（Copying）**：按 8:1 的比例划分出一块 Eden 空间和两块 Survivor 空间（S0 和 S1），回收时将 Eden 和 S0 里的内存直接 Copy 到 S1 中，如果 S1 中没有足够的空间，这些对象将通过分配担保（Handle Promotion）机制进入老年代。这种算法的缺点是对对象存活率较高的老年代并不适用。
- **标记-整理算法（Mark-Compact）**：与标记整理类似，但标记后并不是直接对可回收对象进行清理，而是先让所有存活对象移向一端，然后直接清理掉端边界以外的内存。

在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。

如图所示，默认情况下新生代和老年占用空间比例为1：2，新生代中Eden:S0:S1=8:1:1，无论什么时候，总是有一块 Survivor 区域是空闲着的，原因后面会讲到。

![](/images/JVM_heap.png)

<center>图片来自：<https://www.slideshare.net/rgrebski/on-heap-cache-vs-offheap-cache-53098109></center>

## Heap GC——分代收集

Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。

### Minor GC

Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。

新对象在 Eden + S0 中诞生，一旦 Eden 区将满，JVM 会因为申请不到内存触发一次 Minor GC，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳，则使用复制算法将这些仍然存活的对象复制到 S1 区域，然后清理 Edent 和 S0，并将 S0 和 S1 互换，以便执行下一次 GC。年轻代的中的对象每经历一次 Minor GC，对象的年龄会 +1，默认情况下对象年龄达到15（可以通过参数 -XX:MaxTenuringThreshold 来设定），则会被分配到老年代。
但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。

### Full GC

Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

较大型的对象会直接进入Old代，另外再Young中生存的时间很长的可达对象也会进入Old代，老年代的对象是不容易死掉的，也就意味着 Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。

另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

## JVM 参数选项

jvm 可配置的参数选项可以参考 Oracle 官方网站给出的相关信息：<http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html>

下面只列举其中的几个常用和容易掌握的配置选项：

| -Xms                            | 初始堆大小。如：-Xms256m                         |
| ------------------------------- | ---------------------------------------- |
| -Xmx                            | 最大堆大小。如：-Xmx512m                         |
| -Xmn                            | 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% |
| -Xss                            | JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。 |
| -XX:NewRatio                    | 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3 |
| -XX:SurvivorRatio               | 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 |
| -XX:PermSize                    | 永久代(方法区)的初始大小                            |
| -XX:MaxPermSize                 | 永久代(方法区)的最大值                             |
| -XX:+PrintGCDetails             | 打印 GC 信息                                 |
| -XX:+HeapDumpOnOutOfMemoryError | 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用      |

# 垃圾收集器



# 再谈内存分配

