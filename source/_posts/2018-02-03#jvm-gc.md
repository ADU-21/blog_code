---
title: Java系列（二）——JAVA GC
date: 2018-02-03 23:15:15
categories: Java
tags:
- Java
---

GC（Garbage Collection 垃圾回收）使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。

# 哪些内存需要回收

上文[JVM内存分配](https://www.duyidong.com/2018/01/31/jvm/)介绍了 JVM 运行时内存分配的各个部分，其中程序计数器、虚拟机栈、本地方法区都是和线程同生共死的，其内存的分配和回收都随着栈帧的进入和退出有序进行，不需要过多考虑回收问题。而 **Java 堆**和**方法区**因为其存放对象和类都是要在运行时才能确认大小，而创建的动作频繁且随机，因此这两部分区域是 GC 关注的主要区域。

# 什么时候回收

## Java 堆里的对象实例

Java 堆里存放着 JVM 中几乎所有的对象实例，判断 Stack 中哪些内存可以被回收，首先就得看哪些对象实例已经“死去”，即不可能再被使用。我们先来看两个简单的实现方式：**引用计数算法**发和**可达性分析算法**。

### 引用计数算法（Reference Counting Collector）

这是在 Python 里被使用的 GC 算法，也是 GC 早期中的早期策略，其实现就是给每一个对象添加一个应用计数器，没有一个地方引用它就加1，当应用失效时就减1，当计数器为0时则说明这个对象不再被使用。这种实现方式简单高效，却有一个比较大的问题导致主流 Java 虚拟机都没有采纳这种方式，就是它无法解决<u>循环引用</u>的问题。例子可见：[java垃圾回收之循环引用](http://blog.csdn.net/sunmenggmail/article/details/8172273)。

### 可达性分析算法（Reachability Analysis）

这种算法是真正被主流商用语言采纳的 GC 算法，其思路是通过通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链（Reference Chain），成为一个树状结构，当所有根节点（GC root）到某个对象都不可达时，则说明这个对象是不可用的。

有以下几种对象可以被作为 GC Roots:

```
- Java Stack 中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法中 Native 方法引用的对象。
```

值得注意的是，这些不可达对象并不是会立即被清理掉，而是会被进行一次标记，如果该对象覆写了 finalize() 方法且还没有被调用过，则会被放到一个叫 F-Queue 的队列中，这个 finalize 方法原本是用于手动释放非 Java 内存的，但是 JVM 并不一定会执行它；如果在 finalize 方法中对象与引用链上的任一对象发生引用，这个对象就会“起死回生”，在第二次 GC 标记 F-Queue 中对象的时候被移除回收集合。finalize 方法最多只会被执行一次，不确定性大，所以不推荐使用。

#### 关于引用

可达性分析算法中对引用的划分仅限于“引用”和“未引用”，而事实上在程序运行中还有一类“暂时没被引用”的对象，这部分对象我们希望在内存充裕的情况下保留，在内存紧张的时候再将其抛弃。因此在 JDK1.2 后，Java 将引用的概念扩充至强引用（Strong Reference）、软引用（Weak Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference），分别用来描述有用（new）、有用但非必须（OOM 前回收）、非必须引用（下一次 GC 回收），以及不影响对象生命周期的引用（用于系统回收通知）。

## 方法区里的类

方法区（Method Area）对应 Java7 以前的持久代（Permanent generation），已经在 Java8中被移除，取而代之的是使用本地内存的 MetaSpace，其 GC 频率也大幅降低，只有当 MetaSpace 内存达到“MaxMetaspaceSize”值的时候才会触发一次该区域的 GC。根据 JVM 规范，满足以下三个条件的类将被定义为“可以被搜集”：

```
- 该类的所有实例都已经被回收。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
```

当然，被标记“可以回收”的类还要视 JVM 的参数（-Xnoclassgc）决定是否被回收。

# 如何回收

## 算法

在 Hotspot JVM 里，Java 堆采用分代收集（Generational Collection），在了解分代收集之前先来看几种简单的算法：

- **标记-清除算法（Mark-Sweep）**：分为“标记”和“清除”两个阶段，将需要清除的内存标记后随即清除，因为绝大部分的对象都只存在很短的时间就需要被收回，这种算法显得很低效；而且会产生大量不连续的存储空间。
- **复制算法（Copying）**：按 8:1 的比例划分出一块 Eden 空间和两块 Survivor 空间（S0 和 S1），回收时将 Eden 和 S0 里的内存直接 Copy 到 S1 中，如果 S1 中没有足够的空间，这些对象将通过分配担保（Handle Promotion）机制进入老年代。这种算法的缺点是对对象存活率较高的老年代并不适用。
- **标记-整理算法（Mark-Compact）**：与标记整理类似，但标记后并不是直接对可回收对象进行清理，而是先让所有存活对象移向一端，然后直接清理掉端边界以外的内存。

分代收集算法，综合了以上三种算法，将 Java 堆分为新生代和老年区，再分别采用复制算法和标记-清理算法，达到最佳回收效率。

## HotSpot 实现



# 垃圾收集器



# 再谈内存分配

