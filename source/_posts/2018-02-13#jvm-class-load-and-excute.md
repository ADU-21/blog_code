---
title: Java系列——类的加载与执行
date: 2018-02-13 21:03:40
categories: Java
tags:
- Java
- Class
- JVM
- 学习
- 小结
---

清楚了 JVM 内存结构、GC、类结构，[上篇文章](/2018/02/11/java-class-file-structure/)我们知道了字节码是 JVM 实现无关性的重要设计，这篇文章我们来看一下这些字节码文件是如何被虚拟机加载和执行的。

# 虚拟机类加载机制

Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。其中准备、验证、解析3个部分统称为连接（Linking），如图所示：

![](/images/java_class_lifecycle.jpg)

下面我们来一步一步的看类是如何被加载的。

## 类加载的时机

虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

```
- 遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。

- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。

- 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
```

- 通过子类引用父类的静态字段，不会导致子类初始化。是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。
- 通过数组定义来引用类，不会触发此类的初始化。比如SupperClass[] sca = new SupperClass[10];这里不会初始化SupperClass，但是触发了另外一个名为“com.gavin.SuperClass”的类的初始化阶段，它是一个由虚拟机自动生成的，直接继承于Object的子类，创建动作由字节码指令newarray触发。
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量类的初始化。比如“private static final CONST="123"”,不会引发此类的初始化。
- 当一个类在初始化的时候，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父类接口全部完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 类加载的过程

- **加载**

  把存储类的实体从各类介质(文件/网络/数据库/内存中实时生成等)加载到 JVM 内存的方法区中，生成对应对象```java.lang.Class```。数组类不通过类的加载器创建，而是由虚拟机直接创建，但数组类的元素类型（Element Type）需要类加载器创建。

- **验证**

  为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，，并且不会危害虚拟机的安全，如果验证失败，会抛出 java.lang.VerifyError 异常。验证过程较为复杂，JVM主要验证了class文件格式/java语义限制/java程序逻辑正确性和安全性，其主要技术为<u>静态的字节码分析</u>，所以不能保证100%的可靠。

- **准备**

  为类的<u>静态变量</u>分配内存并初始化为零值，final 则赋真实值，这些变量所使用的内存都将在方法区中进行分配。

- **解析**

  将<u>符号引用</u>（如方法名/变量名/类等等的符号）转化为<u>直接引用</u>（直接指向一块内存区域）的过程,所有符号引用都必须转化为直接引用。

- **初始化**

  在初始化之前，程序已经可以在内存中访问类和它的变量了，这个时候 JVM 会调用类构造器```<clinit>()```在类被主动引用前，按代码赋初值的计划去给这些变量赋予一个值，它与实例加载时调用的构造器```<init>()```不同，不需要显示调用父类构造器，而是由虚拟机保证父类```<clinit>()```已经执行，这也就意味着父类中定义的静态语句优先级要高于子类变量的赋值操作。

  如果一个类没有静态语句块，也没有对变量的复制操作，编译器可以部位这个类生成```<clinit>()```方法。

  接口的```<clinit>()```是单独执行的，不会受继承和类实现的影响。

  虚拟机会保证一个类的```<clinit>()```方法在多线程环境中被加锁、同步，因此如果在一个类的```<clinit>()```方法中有耗时操作，就会造成多个进程阻塞。

- **使用**

  当初始化完成之后，java 虚拟机就可以根据```new```或反射的调用执行Class的业务逻辑指令，通过堆中java.lang.Class对象的入口地址，调用方法区的方法逻辑，最后将方法的运算结果通过方法返回地址存放到方法区或堆中。

- **卸载**

  参见[Java系列（二）——JVM内存回收](/2018/02/09/jvm-gc/)的[什么时候回收-方法区里的类](https://www.duyidong.com/2018/02/09/jvm-gc/#%E6%96%B9%E6%B3%95%E5%8C%BA%E9%87%8C%E7%9A%84%E7%B1%BB)部分。

# 虚拟机字节码执行引擎









> * References:
> * <https://gavinzhang1.gitbooks.io/java-jvm-us/content/xu_ni_ji_lei_jia_zai_ji_zhi.html>
> * <https://segmentfault.com/a/1190000010048751>
> * <http://www.cnblogs.com/hnlshzx/p/3533264.html>
> * <http://blog.csdn.net/justloveyou_/article/details/72466105>